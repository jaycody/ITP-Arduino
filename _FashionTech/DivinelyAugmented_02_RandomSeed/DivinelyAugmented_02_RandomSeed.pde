/* jason stephens
 Fashion Tech - Fall 2011
 Divination Augmentation
 
 Idea:  
    This Body Augmentation incorporates divination into human interactions.
    The Augmentation expresses the Divined Information 
      as either Synchronized (YES) or Unsychronized (NO) LED Blinking   
    The Suit itself has 4 discrete settings:
      ON:  2 shoulder mounted LEDs in the ON position
      DIVINING:  Randomizing of the LED states
      ANSWERING:  Displaying either YES = Synchronized Blinking | NO = Alternated Blinking
      OFF: Both LEDs are off
 
 Method:
   Divination expressed by Two LEDs (PIN 9 and 10) attached to the shoulders of a suit.  
     Synchronized Blink = yes.  
     Alternating Blink = No.
   LightSensitive Resitor on Lapel Acts as Switch
     (Power to LSR Then SPLIT between (Analog Pin A0) and (10k to Ground))
     Threshold For LSR as Switch is set by the variable "photoSensitivity"
   randomSeed generated by Anolog Noise from Pin A1 (at startup) and A2 after every 3rd button press.
   Normal PushButton Switch (Pin11) for BackUp
     5V to Switch.  When pushed -> divided between (Pin11) and (10k resistor to Ground))
    
 
 LilyPad Setup:
   Lilypad attached to inside pocket of sport coat.  One LED to Pin9, One LED to Pin10
   LipoBattery inside sportcoat inner pocket alongside LilyPad
   
 Adapted from:
   Fade
   This example shows how to fade an LED on pin 9
   using the analogWrite() function.
   This example code is in the public domain.
 
 TODO:
 _______Setup randomSeed call
 
 
 */

int LED1Pin = 9;
int LED2Pin =10;
int Button1 = 11;


int LED1state = 1;
int LED2state = 1; 

// Button Variables
int ButtonCounter = 0;
int Button1state = 0;
int LastButtonState = 0;

// Debounce time
long lastDebounceTime = 0;
long debounceDelay = 50;

// FADE variables
int brightness = 0;
int fadeAmount = 20;
long previousMillis = 0;
long interval = 400;  // blinking without using the fader
long intervalOffSet = 150;

// PhotoResitor variables
int photoResistorVal;
int photoResistorMax=0; //setting the range of the light sensor
int photoResistorMin=1023;
int photoMap;
int photoMapReadPrevious;
int photoSensitivity = 500;  //determines how sensitive the photoresitor is to being a swithch


void setup()  { 
  // declare pin 9 to be an output:
  pinMode(LED1Pin, OUTPUT);
  pinMode(LED2Pin, OUTPUT);
  pinMode(Button1, INPUT);

  //calibrate the photoResistor Button
  photoMapReadPrevious = photoSensitivity + 1;
  
  Serial.begin (9600);
  randomSeed(analogRead(A1)); //begin first randomSeed with NOISE from unused Analog Input
} 

void loop()  { 
  //Serial.begin (9600);

  photoResistor();
  photoResistorStateChange();

  Button1stateChange();

  resetCounter ();

  stateAction();

  serialPrint();
}

void photoResistor () {

  photoResistorVal = analogRead(A0);
  if (photoResistorVal > photoResistorMax) {
    photoResistorMax = photoResistorVal;
  }

  if (photoResistorVal < photoResistorMin) {
    photoResistorMin = photoResistorVal;
  }
  Serial.print(" | photoResMin= ");
  Serial.print(photoResistorMin);
  Serial.print(" | photoResMax= ");
  Serial.print(photoResistorMax);

  //map the Resistor value to a larger number to spread it out then use the number as a button
  photoMap = map ( photoResistorVal, 500, photoResistorMax, 0,1000);
  Serial.print(" | photoMap= ");
  Serial.print(photoMap); 
}

void photoResistorStateChange(){
  //read incoming from mapped sensor
  int photoMapRead = photoMap;
  //Detect State Change
  if (photoMapRead < photoSensitivity){
    if (photoMapReadPrevious > photoSensitivity) {
      ButtonCounter++;
    }
  }
  photoMapReadPrevious = photoMapRead;
}






void Button1stateChange() {
  //read the Switch at input pin
  //add a "reading variable"  and measure it's time before assigning it Button1State
  int reading = digitalRead(Button1);
  //DEBOUNCE
  //compare the just read Button state to its previous state
  if (reading != LastButtonState) {
    //reset the debounce time
    lastDebounceTime = millis();
  }
  //if the delay criteria is met, then we believe it is an actual button push
  if ((millis()- lastDebounceTime ) > debounceDelay) {
    Button1state = reading;
  }
  // DETECT STATE CHANGE
  if (Button1state  != LastButtonState){
    if (Button1state == HIGH) {
      ButtonCounter++;
    }
  }
  //save the current state as the last state
  LastButtonState = reading;
}


void resetCounter(){
  if (ButtonCounter % 4 == 0){
    ButtonCounter = 0;
  }
}


void stateAction (){
  if (ButtonCounter == 0) {
    digitalWrite (LED1Pin, HIGH);
    digitalWrite (LED2Pin, HIGH);
    Serial.print (" LED1 = 1");
    Serial.println (" LED2 = 1");
  }

  if (ButtonCounter == 1) {
    // if we create variable inside the loop, then they stay there...
    LED1state = random(2);  //these local variable stay within the loop
    LED2state = random(2);
    digitalWrite (LED1Pin, LED1state);
    digitalWrite (LED2Pin, LED2state);
    Serial.print (" LED1 = ");
    Serial.print (LED1state);
    Serial.print (" LED2 = ");
    Serial.println (LED2state);
  }   

  /*at the count of 2, freeze random states, unless Double Zero, in which case, make both HIGH
   if either/or then blink NO
   */
  if (ButtonCounter == 2) {

    // get Synchronized blinking if YES | get alternating blink if NO
    if (((LED1state == 0) && (LED2state == 0)) || ((LED1state == 1) && (LED2state == 1))) {
      unsigned long currentMillis = millis();

      if(currentMillis - previousMillis > interval) {
        // save the last time you blinked the LED 
        previousMillis = currentMillis;   

        // if the LED is off turn it on and vice-versa:
        if (LED1state == LOW)
          LED1state = HIGH;
        else
          LED1state = LOW;
        // set the LED with the ledState of the variable:
        digitalWrite(LED1Pin, LED1state);

        if (LED2state == LOW)
          LED2state = HIGH;
        else
          LED2state = LOW;
        // set the LED with the ledState of the variable:
        digitalWrite(LED2Pin, LED2state);

//        Serial.print (" LED1 = ");
//        Serial.print (LED1state);
//        Serial.print (" LED2 = ");
//        Serial.println (LED2state);
      }
         Serial.print (" LED1 = ");
        Serial.print (LED1state);
        Serial.print (" LED2 = ");
        Serial.println (LED2state);
    }
    else {
      // all other combos of  EITHER OR get to ALTERNATING blink
      unsigned long currentMillis = millis();

      if(currentMillis - previousMillis > intervalOffSet) {
        // save the last time you blinked the LED 
        previousMillis = currentMillis;   

        // if the LED is off turn it on and vice-versa:
        if (LED1state == LOW)
          LED1state = HIGH;
        else
          LED1state = LOW;
        // set the LED with the ledState of the variable:
        digitalWrite(LED1Pin, LED1state);

        if (LED2state == HIGH)
          LED2state = LOW;
        else
          LED2state = HIGH;
        // set the LED with the ledState of the variable:
        digitalWrite(LED2Pin, LED2state);
      }
      Serial.print (" LED1 =");
      Serial.print (LED1state);
      Serial.print (" LED2 =");
      Serial.println (LED2state);     
    }
  }
  //or brightness shift
  if (ButtonCounter == 3) {

    // set both to LOW to "reset"
    analogWrite(LED1Pin, LOW);   
    analogWrite(LED2Pin, LOW);    
    Serial.print (" LED1 = OFF");
    Serial.println (" LED2 = OFF");
    
    randomSeed(analogRead(A2));

  }

}

void serialPrint () {
  Serial.print("number of pushes:  ");
  Serial.print(ButtonCounter, DEC);
  //write it out

}






















